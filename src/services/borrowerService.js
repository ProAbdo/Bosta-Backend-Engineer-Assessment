const { Borrower, BorrowingRecord, Book } = require('../models');const { Op } = require('sequelize');class BorrowerService {  async getAllBorrowers(page = 1, limit = 10) {    const offset = (page - 1) * limit;    const { count, rows: borrowers } = await Borrower.findAndCountAll({      order: [['name', 'ASC']],      limit,      offset    });    return {      borrowers,      pagination: {        page,        limit,        total: count,        pages: Math.ceil(count / limit)      }    };  }  async getBorrowerById(id) {    return await Borrower.findByPk(id);  }  async getBorrowerByEmail(email) {    return await Borrower.findOne({      where: { email }    });  }  async searchBorrowers(query) {    console.log("query", query);    return await Borrower.findAll({      where: {        [Op.or]: [          { name: { [Op.like]: `%${query}%` } },          { email: { [Op.like]: `%${query}%` } }        ]      },      order: [['name', 'ASC']]    });  }  async createBorrower(borrowerData) {    const { name, email, phone, address } = borrowerData;    const existingBorrower = await Borrower.findOne({      where: { email }    });    if (existingBorrower) {      throw new Error('Borrower with this email already exists');    }    return await Borrower.create({      name,      email,      phone,      address,      registered_date: new Date()    });  }  async updateBorrower(id, updateData) {    const borrower = await Borrower.findByPk(id);    if (!borrower) {      throw new Error('Borrower not found');    }    if (updateData.email && updateData.email !== borrower.email) {      const existingBorrower = await Borrower.findOne({        where: {           email: updateData.email,          id: { [Op.ne]: id }        }      });      if (existingBorrower) {        throw new Error('Borrower with this email already exists');      }    }    await borrower.update(updateData);    return borrower;  }  async deleteBorrower(id) {    const borrower = await Borrower.findByPk(id);    if (!borrower) {      throw new Error('Borrower not found');    }    const activeBorrowings = await BorrowingRecord.findOne({      where: {         borrower_id: id,        status: 'checked_out'      }    });    if (activeBorrowings) {      throw new Error('Cannot delete borrower with active borrowings');    }    await borrower.destroy();    return true;  }  async getBorrowingHistory(id, includeReturned = true) {    const whereClause = { borrower_id: id };    if (!includeReturned) {      whereClause.status = 'checked_out';    }    return await BorrowingRecord.findAll({      where: whereClause,      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn']        }      ],      order: [['checkout_date', 'DESC']]    });  }  async getCurrentlyBorrowedBooks(id) {    return await BorrowingRecord.findAll({      where: {         borrower_id: id,        status: 'checked_out'      },      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn', 'shelf_location']        }      ],      order: [['due_date', 'ASC']]    });  }  async getOverdueBooks(id) {    const now = new Date();    return await BorrowingRecord.findAll({      where: {         borrower_id: id,        status: 'checked_out',        due_date: { [Op.lt]: now }      },      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn']        }      ],      order: [['due_date', 'ASC']]    });  }  async getBorrowerStatistics(id) {    const totalBorrowings = await BorrowingRecord.count({      where: { borrower_id: id }    });    const currentBorrowings = await BorrowingRecord.count({      where: {         borrower_id: id,        status: 'checked_out'      }    });    const overdueBorrowings = await BorrowingRecord.count({      where: {         borrower_id: id,        status: 'checked_out',        due_date: { [Op.lt]: new Date() }      }    });    const returnedBorrowings = await BorrowingRecord.count({      where: {         borrower_id: id,        status: 'returned'      }    });    return {      totalBorrowings,      currentBorrowings,      overdueBorrowings,      returnedBorrowings,      activeRate: totalBorrowings > 0 ? ((currentBorrowings / totalBorrowings) * 100).toFixed(2) : 0    };  }  async getAllBorrowersWithStats() {    const borrowers = await Borrower.findAll({      order: [['name', 'ASC']]    });    const borrowersWithStats = await Promise.all(      borrowers.map(async (borrower) => {        const stats = await this.getBorrowerStatistics(borrower.id);        return {          ...borrower.toJSON(),          stats        };      })    );    return borrowersWithStats;  }}module.exports = new BorrowerService();