const bcrypt = require('bcryptjs');const jwt = require('jsonwebtoken');const { User } = require('../models');const { Op } = require('sequelize');class UserService {  async createUser(userData) {    const { username, email, password, role = 'librarian' } = userData;    const existingUsername = await User.findOne({      where: { username }    });    if (existingUsername) {      throw new Error('Username already exists');    }    const existingEmail = await User.findOne({      where: { email }    });    if (existingEmail) {      throw new Error('Email already exists');    }    const saltRounds = 10;    const passwordHash = await bcrypt.hash(password, saltRounds);    const user = await User.create({      username,      email,      password_hash: passwordHash,      role    });    const { password_hash, ...userWithoutPassword } = user.toJSON();    return userWithoutPassword;  }  async authenticateUser(username, password) {    const user = await User.findOne({      where: { username }    });    if (!user) {      throw new Error('Invalid username or password');    }    const isValidPassword = await bcrypt.compare(password, user.password_hash);    if (!isValidPassword) {      throw new Error('Invalid username or password');    }    const token = jwt.sign(      {        id: user.id,        username: user.username,        email: user.email,        role: user.role      },      process.env.JWT_SECRET || 'your-secret-key',      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }    );    const { password_hash, ...userWithoutPassword } = user.toJSON();    return {      user: userWithoutPassword,      token    };  }  async getUserById(id) {    const user = await User.findByPk(id);    if (!user) return null;    const { password_hash, ...userWithoutPassword } = user.toJSON();    return userWithoutPassword;  }  async getUserByUsername(username) {    const user = await User.findOne({      where: { username }    });    if (!user) return null;    const { password_hash, ...userWithoutPassword } = user.toJSON();    return userWithoutPassword;  }  async getUserByEmail(email) {    const user = await User.findOne({      where: { email }    });    if (!user) return null;    const { password_hash, ...userWithoutPassword } = user.toJSON();    return userWithoutPassword;  }  async updateUser(id, updateData) {    const user = await User.findByPk(id);    if (!user) {      throw new Error('User not found');    }    if (updateData.username && updateData.username !== user.username) {      const existingUsername = await User.findOne({        where: {           username: updateData.username,          id: { [Op.ne]: id }        }      });      if (existingUsername) {        throw new Error('Username already exists');      }    }    if (updateData.email && updateData.email !== user.email) {      const existingEmail = await User.findOne({        where: {           email: updateData.email,          id: { [Op.ne]: id }        }      });      if (existingEmail) {        throw new Error('Email already exists');      }    }    await user.update(updateData);    const { password_hash, ...userWithoutPassword } = user.toJSON();    return userWithoutPassword;  }  async changePassword(id, currentPassword, newPassword) {    const user = await User.findByPk(id);    if (!user) {      throw new Error('User not found');    }    const isValidPassword = await bcrypt.compare(currentPassword, user.password_hash);    if (!isValidPassword) {      throw new Error('Current password is incorrect');    }    const saltRounds = 10;    const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);    await user.update({ password_hash: newPasswordHash });    return true;  }  async resetPassword(id, newPassword) {    const user = await User.findByPk(id);    if (!user) {      throw new Error('User not found');    }    const saltRounds = 10;    const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);    await user.update({ password_hash: newPasswordHash });    return true;  }  async deleteUser(id) {    const user = await User.findByPk(id);    if (!user) {      throw new Error('User not found');    }    if (user.role === 'admin') {      const adminCount = await User.count({        where: { role: 'admin' }      });      if (adminCount <= 1) {        throw new Error('Cannot delete the last admin user');      }    }    await user.destroy();    return true;  }  async getAllUsers(page = 1, limit = 10, role = null) {    const offset = (page - 1) * limit;    const whereClause = {};    if (role) {      whereClause.role = role;    }    const { count, rows: users } = await User.findAndCountAll({      where: whereClause,      attributes: { exclude: ['password_hash'] },      order: [['username', 'ASC']],      limit,      offset    });    return {      users,      pagination: {        page,        limit,        total: count,        pages: Math.ceil(count / limit)      }    };  }  async verifyToken(token) {    try {      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');      return decoded;    } catch (error) {      throw new Error('Invalid token');    }  }  async getUserStatistics() {    const totalUsers = await User.count();    const adminUsers = await User.count({      where: { role: 'admin' }    });    const librarianUsers = await User.count({      where: { role: 'librarian' }    });    return {      total: totalUsers,      admins: adminUsers,      librarians: librarianUsers,      adminPercentage: totalUsers > 0 ? ((adminUsers / totalUsers) * 100).toFixed(2) : 0    };  }  async searchUsers(query) {    return await User.findAll({      where: {        [Op.or]: [          { username: { [Op.like]: `%${query}%` } },          { email: { [Op.like]: `%${query}%` } }        ]      },      attributes: { exclude: ['password_hash'] },      order: [['username', 'ASC']]    });  }}module.exports = new UserService();