const { Book, BorrowingRecord } = require('../models');const { Op } = require('sequelize');class BookService {  async getAllBooks(page = 1, limit = 10) {    const offset = (page - 1) * limit;    const { count, rows: books } = await Book.findAndCountAll({      order: [['title', 'ASC']],      limit,      offset    });    return {      books,      pagination: {        page,        limit,        total: count,        pages: Math.ceil(count / limit)      }    };  }  async getBookById(id) {    return await Book.findByPk(id);  }  async searchBooks(query, type = 'all') {    let whereClause = {};    switch (type) {      case 'title':        whereClause = {          title: { [Op.like]: `%${query}%` }        };        break;      case 'author':        whereClause = {          author: { [Op.like]: `%${query}%` }        };        break;      case 'isbn':        whereClause = {          isbn: { [Op.like]: `%${query}%` }        };        break;      default:        whereClause = {          [Op.or]: [            { title: { [Op.like]: `%${query}%` } },            { author: { [Op.like]: `%${query}%` } },            { isbn: { [Op.like]: `%${query}%` } }          ]        };    }    return await Book.findAll({      where: whereClause,      order: [['title', 'ASC']]    });  }  async createBook(bookData) {    const { title, author, isbn, available_quantity, total_quantity, shelf_location } = bookData;    const existingBook = await Book.findOne({      where: { isbn }    });    if (existingBook) {      throw new Error('Book with this ISBN already exists');    }    return await Book.create({      title,      author,      isbn,      available_quantity,      total_quantity,      shelf_location    });  }  async updateBook(id, updateData) {    const book = await Book.findByPk(id);    if (!book) {      throw new Error('Book not found');    }    if (updateData.isbn && updateData.isbn !== book.isbn) {      const existingBook = await Book.findOne({        where: {           isbn: updateData.isbn,          id: { [Op.ne]: id }        }      });      if (existingBook) {        throw new Error('Book with this ISBN already exists');      }    }    await book.update(updateData);    return book;  }  async deleteBook(id) {    const book = await Book.findByPk(id);    if (!book) {      throw new Error('Book not found');    }    const borrowedBook = await BorrowingRecord.findOne({      where: {         book_id: id,        status: 'checked_out'      }    });    if (borrowedBook) {      throw new Error('Cannot delete book that is currently borrowed');    }    await book.destroy();    return true;  }  async getBooksByAvailability(available = true) {    const whereClause = available       ? { available_quantity: { [Op.gt]: 0 } }      : { available_quantity: 0 };    return await Book.findAll({      where: whereClause,      order: [['title', 'ASC']]    });  }  async getBooksByAuthor(author) {    return await Book.findAll({      where: {        author: { [Op.like]: `%${author}%` }      },      order: [['title', 'ASC']]    });  }  async updateBookQuantity(id, change) {    const book = await Book.findByPk(id);    if (!book) {      throw new Error('Book not found');    }    const newAvailableQuantity = book.available_quantity + change;    if (newAvailableQuantity < 0) {      throw new Error('Insufficient book quantity');    }    if (newAvailableQuantity > book.total_quantity) {      throw new Error('Available quantity cannot exceed total quantity');    }    await book.update({ available_quantity: newAvailableQuantity });    return book;  }  async getBookStatistics() {    const totalBooks = await Book.count();    const availableBooks = await Book.count({      where: { available_quantity: { [Op.gt]: 0 } }    });    const borrowedBooks = totalBooks - availableBooks;    return {      total: totalBooks,      available: availableBooks,      borrowed: borrowedBooks,      utilizationRate: totalBooks > 0 ? ((borrowedBooks / totalBooks) * 100).toFixed(2) : 0    };  }}module.exports = new BookService();