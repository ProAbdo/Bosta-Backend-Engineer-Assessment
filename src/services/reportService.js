const { Book, Borrower, BorrowingRecord, User, sequelize } = require('../models');const { Op } = require('sequelize');const ExcelJS = require('exceljs');const createCsvWriter = require('csv-writer').createObjectCsvWriter;class ReportService {  async getBorrowingAnalytics(startDate, endDate) {    const whereClause = {      checkout_date: {        [Op.between]: [startDate, endDate]      }    };    const totalBorrowings = await BorrowingRecord.count({ where: whereClause });    const returnedBooks = await BorrowingRecord.count({      where: { ...whereClause, status: 'returned' }    });    const overdueBooks = await BorrowingRecord.count({      where: {         ...whereClause,        status: 'checked_out',        due_date: { [Op.lt]: new Date() }      }    });    const dailyTrends = await BorrowingRecord.findAll({      where: whereClause,      attributes: [        [sequelize.fn('DATE', sequelize.col('checkout_date')), 'date'],        [sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'count']      ],      group: [sequelize.fn('DATE', sequelize.col('checkout_date'))],      order: [[sequelize.fn('DATE', sequelize.col('checkout_date')), 'ASC']]    });    const topBooks = await BorrowingRecord.findAll({      where: whereClause,      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author']        }      ],      attributes: [        'book_id',        [sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'borrowCount']      ],      group: ['book_id'],      order: [[sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'DESC']],      limit: 10    });    const topBorrowers = await BorrowingRecord.findAll({      where: whereClause,      include: [        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ],      attributes: [        'borrower_id',        [sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'borrowCount']      ],      group: ['borrower_id'],      order: [[sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'DESC']],      limit: 10    });    return {      period: { startDate, endDate },      summary: {        totalBorrowings,        returnedBooks,        overdueBooks,        returnRate: totalBorrowings > 0 ? ((returnedBooks / totalBorrowings) * 100).toFixed(2) : 0,        overdueRate: totalBorrowings > 0 ? ((overdueBooks / totalBorrowings) * 100).toFixed(2) : 0      },      dailyTrends,      topBooks,      topBorrowers    };  }  async getBookInventoryReport() {    const totalBooks = await Book.count();    const availableBooks = await Book.count({      where: { available_quantity: { [Op.gt]: 0 } }    });    const borrowedBooks = totalBooks - availableBooks;    const availableBookList = await Book.findAll({      where: { available_quantity: { [Op.gt]: 0 } },      order: [['title', 'ASC']]    });    const borrowedBookList = await Book.findAll({      where: { available_quantity: 0 },      order: [['title', 'ASC']]    });    const lowStockBooks = await Book.findAll({      where: {         available_quantity: { [Op.lt]: 2 },        available_quantity: { [Op.gt]: 0 }      },      order: [['available_quantity', 'ASC']]    });    const outOfStockBooks = await Book.findAll({      where: { available_quantity: 0 },      order: [['title', 'ASC']]    });    return {      summary: {        totalBooks,        availableBooks,        borrowedBooks,        utilizationRate: totalBooks > 0 ? ((borrowedBooks / totalBooks) * 100).toFixed(2) : 0      },      availableBookList,      borrowedBookList,      lowStockBooks,      outOfStockBooks    };  }  async getBorrowerActivityReport(startDate, endDate) {    const whereClause = {      checkout_date: {        [Op.between]: [startDate, endDate]      }    };    const activeBorrowers = await BorrowingRecord.findAll({      where: whereClause,      include: [        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ],      attributes: [        'borrower_id',        [sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'borrowCount']      ],      group: ['borrower_id'],      order: [[sequelize.fn('COUNT', sequelize.col('BorrowingRecord.id')), 'DESC']]    });    const allBorrowers = await Borrower.findAll();    const activeBorrowerIds = activeBorrowers.map(record => record.borrower_id);    const inactiveBorrowers = allBorrowers.filter(borrower =>       !activeBorrowerIds.includes(borrower.id)    );    const newBorrowers = await Borrower.findAll({      where: {        registered_date: {          [Op.between]: [startDate, endDate]        }      },      order: [['registered_date', 'DESC']]    });    return {      period: { startDate, endDate },      summary: {        totalBorrowers: allBorrowers.length,        activeBorrowers: activeBorrowers.length,        inactiveBorrowers: inactiveBorrowers.length,        newBorrowers: newBorrowers.length,        activityRate: allBorrowers.length > 0 ? ((activeBorrowers.length / allBorrowers.length) * 100).toFixed(2) : 0      },      activeBorrowers,      inactiveBorrowers,      newBorrowers    };  }  async getOverdueBooks() {    return await BorrowingRecord.findAll({      where: {         status: 'checked_out',        due_date: { [Op.lt]: new Date() }      },      include: [        {          model: Book,          as: 'book',          attributes: ['title', 'author', 'isbn']        },        {          model: Borrower,          as: 'borrower',          attributes: ['name', 'email']        }      ],      order: [['due_date', 'ASC']]    });  }  async exportOverdueBooksCSV(startDate, endDate) {    const overdueBooks = await BorrowingRecord.findAll({      where: {         status: 'checked_out',        due_date: {           [Op.lt]: new Date(),          [Op.between]: [startDate, endDate]        }      },      include: [        {          model: Book,          as: 'book',          attributes: ['title', 'author', 'isbn']        },        {          model: Borrower,          as: 'borrower',          attributes: ['name', 'email']        }      ],      order: [['due_date', 'ASC']]    });    const csvHeaders = ['Book Title', 'Book Author', 'ISBN', 'Borrower Name', 'Borrower Email', 'Checkout Date', 'Due Date', 'Days Overdue'];    const csvRows = overdueBooks.map(record => {      const daysOverdue = Math.ceil((new Date() - new Date(record.due_date)) / (1000 * 60 * 60 * 24));      return [        record.book.title,        record.book.author,        record.book.isbn,        record.borrower.name,        record.borrower.email,        record.checkout_date.toISOString().split('T')[0],        record.due_date.toISOString().split('T')[0],        daysOverdue      ];    });    const csvContent = [      csvHeaders.join(','),      ...csvRows.map(row => row.map(field => `"${field}"`).join(','))    ].join('\n');    return csvContent;  }  async exportBorrowingRecordsExcel(startDate, endDate) {    const borrowingRecords = await BorrowingRecord.findAll({      where: {        checkout_date: {          [Op.between]: [startDate, endDate]        }      },      include: [        {          model: Book,          as: 'book',          attributes: ['title', 'author', 'isbn']        },        {          model: Borrower,          as: 'borrower',          attributes: ['name', 'email']        }      ],      order: [['checkout_date', 'DESC']]    });    const workbook = new ExcelJS.Workbook();    const worksheet = workbook.addWorksheet('Borrowing Records');    worksheet.columns = [      { header: 'Book Title', key: 'bookTitle', width: 30 },      { header: 'Book Author', key: 'bookAuthor', width: 25 },      { header: 'ISBN', key: 'isbn', width: 15 },      { header: 'Borrower Name', key: 'borrowerName', width: 25 },      { header: 'Borrower Email', key: 'borrowerEmail', width: 30 },      { header: 'Checkout Date', key: 'checkoutDate', width: 15 },      { header: 'Due Date', key: 'dueDate', width: 15 },      { header: 'Return Date', key: 'returnDate', width: 15 },      { header: 'Status', key: 'status', width: 12 }    ];    borrowingRecords.forEach(record => {      worksheet.addRow({        bookTitle: record.book.title,        bookAuthor: record.book.author,        isbn: record.book.isbn,        borrowerName: record.borrower.name,        borrowerEmail: record.borrower.email,        checkoutDate: record.checkout_date.toISOString().split('T')[0],        dueDate: record.due_date.toISOString().split('T')[0],        returnDate: record.return_date ? record.return_date.toISOString().split('T')[0] : 'N/A',        status: record.status      });    });    worksheet.getRow(1).font = { bold: true };    worksheet.getRow(1).fill = {      type: 'pattern',      pattern: 'solid',      fgColor: { argb: 'FFE0E0E0' }    };    return await workbook.xlsx.writeBuffer();  }  async getSystemOverview() {    const totalBooks = await Book.count();    const totalBorrowers = await Borrower.count();    const totalUsers = await User.count();    const currentBorrowings = await BorrowingRecord.count({      where: { status: 'checked_out' }    });    const overdueBooks = await BorrowingRecord.count({      where: {         status: 'checked_out',        due_date: { [Op.lt]: new Date() }      }    });    const todayBorrowings = await BorrowingRecord.count({      where: {        checkout_date: {          [Op.gte]: new Date().setHours(0, 0, 0, 0)        }      }    });    const todayReturns = await BorrowingRecord.count({      where: {        return_date: {          [Op.gte]: new Date().setHours(0, 0, 0, 0)        }      }    });    return {      books: {        total: totalBooks,        borrowed: currentBorrowings,        available: totalBooks - currentBorrowings,        overdue: overdueBooks      },      borrowers: {        total: totalBorrowers,        active: await this.getActiveBorrowerCount()      },      users: {        total: totalUsers,        admins: await User.count({ where: { role: 'admin' } }),        librarians: await User.count({ where: { role: 'librarian' } })      },      today: {        borrowings: todayBorrowings,        returns: todayReturns      },      system: {        utilizationRate: totalBooks > 0 ? ((currentBorrowings / totalBooks) * 100).toFixed(2) : 0,        overdueRate: currentBorrowings > 0 ? ((overdueBooks / currentBorrowings) * 100).toFixed(2) : 0      }    };  }  async getActiveBorrowerCount() {    const thirtyDaysAgo = new Date();    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);    const activeBorrowers = await BorrowingRecord.findAll({      where: {        checkout_date: {          [Op.gte]: thirtyDaysAgo        }      },      attributes: [        'borrower_id',        [sequelize.fn('DISTINCT', sequelize.col('borrower_id')), 'borrower_id']      ],      group: ['borrower_id']    });    return activeBorrowers.length;  }}module.exports = new ReportService();