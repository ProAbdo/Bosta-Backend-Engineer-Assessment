const { BorrowingRecord, Book, Borrower } = require('../models');const { Op } = require('sequelize');class BorrowingService {  async getAllBorrowingRecords(page = 1, limit = 10) {    const offset = (page - 1) * limit;    const { count, rows: records } = await BorrowingRecord.findAndCountAll({      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn']        },        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ],      order: [['checkout_date', 'DESC']],      limit,      offset    });    return {      records,      pagination: {        page,        limit,        total: count,        pages: Math.ceil(count / limit)      }    };  }  async getBorrowingRecordById(id) {    return await BorrowingRecord.findByPk(id, {      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn', 'shelf_location']        },        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ]    });  }  async checkoutBook(checkoutData) {    const { book_id, borrower_id, due_date, user_id } = checkoutData;    if (new Date(due_date) <= new Date()) {      throw new Error('Due date must be in the future');    }    const book = await Book.findByPk(book_id);    if (!book) {      throw new Error('Book not found');    }    if (book.available_quantity <= 0) {      throw new Error('Book is not available for checkout');    }    const borrower = await Borrower.findByPk(borrower_id);    if (!borrower) {      throw new Error('Borrower not found');    }    const existingCheckout = await BorrowingRecord.findOne({      where: {        book_id,        borrower_id,        status: 'checked_out'      }    });    if (existingCheckout) {      throw new Error('Borrower already has this book checked out');    }    const borrowingRecord = await BorrowingRecord.create({      book_id,      borrower_id,      user_id,      due_date,      status: 'checked_out'    });    await book.update({      available_quantity: book.available_quantity - 1    });    return await this.getBorrowingRecordById(borrowingRecord.id);  }  async returnBook(borrowingId) {    const borrowingRecord = await BorrowingRecord.findByPk(borrowingId);    if (!borrowingRecord) {      throw new Error('Borrowing record not found');    }    if (borrowingRecord.status === 'returned') {      throw new Error('Book is already returned');    }    await borrowingRecord.update({      status: 'returned',      return_date: new Date()    });    const book = await Book.findByPk(borrowingRecord.book_id);    await book.update({      available_quantity: book.available_quantity + 1    });    return await this.getBorrowingRecordById(borrowingId);  }  async getOverdueBooks() {    const now = new Date();    return await BorrowingRecord.findAll({      where: {         status: 'checked_out',        due_date: { [Op.lt]: now }      },      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn']        },        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ],      order: [['due_date', 'ASC']]    });  }  async getBorrowerRecords(borrowerId, status = null) {    const whereClause = { borrower_id: borrowerId };    if (status) {      whereClause.status = status;    }    return await BorrowingRecord.findAll({      where: whereClause,      include: [        {          model: Book,          as: 'book',          attributes: ['id', 'title', 'author', 'isbn']        }      ],      order: [['checkout_date', 'DESC']]    });  }  async getBookBorrowingHistory(bookId) {    return await BorrowingRecord.findAll({      where: { book_id: bookId },      include: [        {          model: Borrower,          as: 'borrower',          attributes: ['id', 'name', 'email']        }      ],      order: [['checkout_date', 'DESC']]    });  }  async updateBorrowingStatus(id, status) {    const validStatuses = ['checked_out', 'returned', 'overdue'];    if (!validStatuses.includes(status)) {      throw new Error('Invalid status. Must be one of: ' + validStatuses.join(', '));    }    const borrowingRecord = await BorrowingRecord.findByPk(id);    if (!borrowingRecord) {      throw new Error('Borrowing record not found');    }    await borrowingRecord.update({ status });    return await this.getBorrowingRecordById(id);  }  async getBorrowingStatistics(startDate = null, endDate = null) {    const whereClause = {};    if (startDate && endDate) {      whereClause.checkout_date = {        [Op.between]: [startDate, endDate]      };    }    const totalBorrowings = await BorrowingRecord.count({ where: whereClause });    const currentBorrowings = await BorrowingRecord.count({      where: { ...whereClause, status: 'checked_out' }    });    const returnedBooks = await BorrowingRecord.count({      where: { ...whereClause, status: 'returned' }    });    const overdueBooks = await BorrowingRecord.count({      where: {         ...whereClause,        status: 'checked_out',        due_date: { [Op.lt]: new Date() }      }    });    return {      totalBorrowings,      currentBorrowings,      returnedBooks,      overdueBooks,      returnRate: totalBorrowings > 0 ? ((returnedBooks / totalBorrowings) * 100).toFixed(2) : 0,      overdueRate: currentBorrowings > 0 ? ((overdueBooks / currentBorrowings) * 100).toFixed(2) : 0    };  }  async processOverdueBooks() {    const now = new Date();    const [updatedCount] = await BorrowingRecord.update(      { status: 'overdue' },      {        where: {          status: 'checked_out',          due_date: { [Op.lt]: now }        }      }    );    return updatedCount;  }  async extendDueDate(id, newDueDate) {    if (new Date(newDueDate) <= new Date()) {      throw new Error('New due date must be in the future');    }    const borrowingRecord = await BorrowingRecord.findByPk(id);    if (!borrowingRecord) {      throw new Error('Borrowing record not found');    }    if (borrowingRecord.status !== 'checked_out') {      throw new Error('Can only extend due date for checked out books');    }    await borrowingRecord.update({ due_date: newDueDate });    return await this.getBorrowingRecordById(id);  }}module.exports = new BorrowingService();