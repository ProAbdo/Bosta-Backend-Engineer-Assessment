const request = require('supertest');const express = require('express');const bookController = require('../controllers/bookController');jest.mock('../config/database', () => ({  pool: {    execute: jest.fn()  }}));const { pool } = require('../config/database');const app = express();app.use(express.json());app.get('/books', bookController.getAllBooks);app.get('/books/:id', bookController.getBookById);app.get('/books/search', bookController.searchBooks);app.post('/books', bookController.addBook);app.put('/books/:id', bookController.updateBook);app.delete('/books/:id', bookController.deleteBook);describe('Book Controller', () => {  beforeEach(() => {    jest.clearAllMocks();  });  describe('GET /books - getAllBooks', () => {    it('should return all books with pagination', async () => {      const mockBooks = [        { id: 1, title: 'Test Book 1', author: 'Author 1' },        { id: 2, title: 'Test Book 2', author: 'Author 2' }      ];      pool.execute        .mockResolvedValueOnce([[{ total: 2 }]])         .mockResolvedValueOnce([mockBooks]);       const response = await request(app)        .get('/books')        .query({ page: 1, limit: 10 });      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBooks);      expect(response.body.pagination).toBeDefined();    });    it('should handle database errors gracefully', async () => {      pool.execute.mockRejectedValue(new Error('Database error'));      const response = await request(app).get('/books');      expect(response.status).toBe(500);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Internal server error');    });  });  describe('GET /books/:id - getBookById', () => {    it('should return a book by ID', async () => {      const mockBook = { id: 1, title: 'Test Book', author: 'Test Author' };      pool.execute.mockResolvedValue([[mockBook]]);      const response = await request(app).get('/books/1');      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBook);    });    it('should return 404 for non-existent book', async () => {      pool.execute.mockResolvedValue([[]]);      const response = await request(app).get('/books/999');      expect(response.status).toBe(404);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Book not found');    });  });  describe('GET /books/search - searchBooks', () => {    it('should search books by title', async () => {      const mockBooks = [{ id: 1, title: 'Test Book', author: 'Test Author' }];      pool.execute.mockResolvedValue([mockBooks]);      const response = await request(app)        .get('/books/search')        .query({ q: 'Test', type: 'title' });      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBooks);      expect(response.body.search.query).toBe('Test');      expect(response.body.search.type).toBe('title');    });    it('should search books by author', async () => {      const mockBooks = [{ id: 1, title: 'Test Book', author: 'Test Author' }];      pool.execute.mockResolvedValue([mockBooks]);      const response = await request(app)        .get('/books/search')        .query({ q: 'Author', type: 'author' });      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBooks);    });    it('should search books by ISBN', async () => {      const mockBooks = [{ id: 1, title: 'Test Book', author: 'Test Author', isbn: '1234567890' }];      pool.execute.mockResolvedValue([mockBooks]);      const response = await request(app)        .get('/books/search')        .query({ q: '123', type: 'isbn' });      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBooks);    });    it('should search all fields when no type specified', async () => {      const mockBooks = [{ id: 1, title: 'Test Book', author: 'Test Author' }];      pool.execute.mockResolvedValue([mockBooks]);      const response = await request(app)        .get('/books/search')        .query({ q: 'Test' });      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.data).toEqual(mockBooks);      expect(response.body.search.type).toBe('all');    });    it('should return 400 when search query is missing', async () => {      const response = await request(app).get('/books/search');      expect(response.status).toBe(400);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Search query is required');    });  });  describe('POST /books - addBook', () => {    it('should add a new book successfully', async () => {      const newBook = {        title: 'New Book',        author: 'New Author',        isbn: '1234567890',        available_quantity: 5,        total_quantity: 5,        shelf_location: 'A1'      };      pool.execute        .mockResolvedValueOnce([[]])         .mockResolvedValueOnce([{ insertId: 1 }])         .mockResolvedValueOnce([[{ id: 1, ...newBook }]]);       const response = await request(app)        .post('/books')        .send(newBook);      expect(response.status).toBe(201);      expect(response.body.success).toBe(true);      expect(response.body.message).toBe('Book added successfully');      expect(response.body.data).toEqual({ id: 1, ...newBook });    });    it('should return 400 when ISBN already exists', async () => {      const newBook = {        title: 'New Book',        author: 'New Author',        isbn: '1234567890',        available_quantity: 5,        total_quantity: 5,        shelf_location: 'A1'      };      pool.execute.mockResolvedValueOnce([[{ id: 1 }]]);       const response = await request(app)        .post('/books')        .send(newBook);      expect(response.status).toBe(400);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Book with this ISBN already exists');    });  });  describe('PUT /books/:id - updateBook', () => {    it('should update a book successfully', async () => {      const updatedBook = {        title: 'Updated Book',        author: 'Updated Author',        isbn: '1234567890',        available_quantity: 3,        total_quantity: 5,        shelf_location: 'A2'      };      pool.execute        .mockResolvedValueOnce([[{ id: 1 }]])         .mockResolvedValueOnce([[]])         .mockResolvedValueOnce([])         .mockResolvedValueOnce([[{ id: 1, ...updatedBook }]]);       const response = await request(app)        .put('/books/1')        .send(updatedBook);      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.message).toBe('Book updated successfully');      expect(response.body.data).toEqual({ id: 1, ...updatedBook });    });    it('should return 404 for non-existent book', async () => {      pool.execute.mockResolvedValueOnce([[]]);       const response = await request(app)        .put('/books/999')        .send({ title: 'Updated Book' });      expect(response.status).toBe(404);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Book not found');    });  });  describe('DELETE /books/:id - deleteBook', () => {    it('should delete a book successfully', async () => {      pool.execute        .mockResolvedValueOnce([[{ id: 1 }]])         .mockResolvedValueOnce([[]]);       const response = await request(app).delete('/books/1');      expect(response.status).toBe(200);      expect(response.body.success).toBe(true);      expect(response.body.message).toBe('Book deleted successfully');    });    it('should return 404 for non-existent book', async () => {      pool.execute.mockResolvedValueOnce([[]]);       const response = await request(app).delete('/books/999');      expect(response.status).toBe(404);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Book not found');    });    it('should return 400 when book is currently borrowed', async () => {      pool.execute        .mockResolvedValueOnce([[{ id: 1 }]])         .mockResolvedValueOnce([[{ id: 1 }]]);       const response = await request(app).delete('/books/1');      expect(response.status).toBe(400);      expect(response.body.success).toBe(false);      expect(response.body.message).toBe('Cannot delete book that is currently borrowed');    });  });});